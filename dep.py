WAITING="waiting"
READY="ready"
STARTED="started"
FAILED="failed"
COMPLETED="completed"

class Obj:
    "Models an any input or output artifact by a set of key-value pairs"
    def __init__(self, id, props):
        """
        :param id:
        :param props: either a dictionary or a sequence of (key, value) tuples
        :return:
        """
        self.id = id
        self.props = dict(props)

    def is_instance_of(self, other):
        """
        :param other: an instance of Obj to compare to
        :return: true of this object has _at_least_ the same properties as "other" does
        """
        for k, v in other.props.items():
            if not (k in self.props and self.props[k] == v):
                return False
        return True

    def get(self, prop_name):
        """
        :param prop_name:
        :return: the value for the given property
        """
        return self.props[prop_name]

    def __repr__(self):
        return "<{} {}>".format(self.id, repr(self.props))



class ObjSet:
    """
    Models the universe of all known artifacts.  Presence in the set does not imply that
    the artifact exists, only that it is used in some rule.

    This prototype implementation does everything in memory but is intended to be replaced with one that read/writes to a persistent DB
    """
    def __init__(self):
        self.objects = {}
        self.next_id = 0

    def get(self, id):
        return self.objects[id]

    def add(self, props):
        # first check to see if this already exists
        matches = self.query(props, is_instance=False)
        assert len(matches) <= 1
        if len(matches) == 1:
            return matches[0].id

        id = self.next_id
        self.next_id += 1

        obj = Obj(id, props)
        self.objects[id] = obj
        return id

    def query(self, properties, is_instance=True):
        result = []
        ref_obj = Obj(None, properties)
        for o in self.objects.values():
            if is_instance:
                if o.is_instance_of(ref_obj):
                    result.append(o)
            else:
                if ref_obj.is_instance_of(o):
                    result.append(o)
        return result

    def clone_with(self, id, **props):
        obj = self.objects[id]
        new_props = dict(obj.props)
        new_props.update(props)
        new_id = self.add(new_props)
        return self.get(new_id)

class Rule:
    """
    Represents a statement describing what transform to run to generate a set of Objs (outputs) from a different set of Objs (inputs)
    """
    def __init__(self, id, inputs, outputs, transform):
        for x in inputs:
            assert isinstance(x, Obj)
        for x in outputs:
            assert isinstance(x, Obj)

        self.inputs = inputs
        self.outputs = outputs
        self.transform = transform
        self.id = id

    def __repr__(self):
        return "<Rule in:{} out:{} transform:{}>".format(self.inputs, self.outputs, self.transform)

class RuleSet:
    """
        The universe of all known rules

        This prototype implementation does everything in memory but is intended to be replaced with one that read/writes to a persistent DB
    """
    def __init__(self):
        # map of rule_id -> state.  If missing entry, state is assumed to be WAITING
        self.rule_state = {}
        self.output_to_rule = {}
        self.rule_by_id = {}
        self.next_rule_id = 0

    def __iter__(self):
        return iter(self.rule_by_id.values())

    def get(self, id):
        return self.rule_by_id[id]

    def remove_rule(self, rule):
        for output in rule.outputs:
            del self.output_to_rule[output]
        del self.rule_by_id[rule.id]

    def add_rule(self, inputs, outputs, transform):
        rule_id = self.next_rule_id
        self.next_rule_id += 1

        rule = Rule(rule_id, inputs, outputs, transform)
        self.rule_by_id[rule_id] = rule

        for output in outputs:
            if (output in self.output_to_rule):
                # if this output was already generated by some rule, drop that rule and replace it
                rule_to_drop = self.output_to_rule[output]
                self.remove_rule(rule_to_drop)
            self.output_to_rule[output] = rule

        return rule_id

    def find_finished_rules(self, output_object, timestamps):
        result = []
        for rule in self.rule_by_id.values():
            if self._get_state(rule, timestamps) == COMPLETED:
                result.append(rule.id)
        return result

    def _get_state(self, rule, timestamps):
        max_input_timestamp = None
        for input in rule.inputs:
            t = timestamps.get(input.id)
            if t == None:
                return WAITING
            if max_input_timestamp == None or max_input_timestamp < t:
                max_input_timestamp = t

        min_output_timestamp = None
        for output in rule.outputs:
            t = timestamps.get(output.id)
            if t == None:
                continue
            if min_output_timestamp == None or min_output_timestamp > t:
                min_output_timestamp = t

        if min_output_timestamp == None or max_input_timestamp > min_output_timestamp:
            return READY

        return COMPLETED

    def find_ready_to_start(self, timestamps, rules_to_consider):
        """
        :param timestamps: a map of object_id -> timestamp the object was created.  (Objects not in the map do not exists)
        :param rules_to_consider: sequence of rule ids to limit ourselves to
        :return: list of rule ids which are ready to execute
        """
        rules_to_start = set()

        for rule_id in rules_to_consider:
            rule = self.rule_by_id[rule_id]
            if self._get_state(rule, timestamps) == READY:
                rules_to_start.add(rule_id)

        return rules_to_start

    def get_rule_state(self, rule_id):
        if rule_id in self.rule_state:
            return self.rule_state[rule_id]
        return WAITING

    def set_rule_state(self, rule_id, state):
        self.rule_state[rule_id] = state

    def get_rules_by_state(self, state):
        result = []
        for rule in self.rule_by_id.values():
            if self.get_rule_state(rule.id) == state:
                result.append(rule)
        return result

    def to_dot(self):
        """
        :return: a graphviz graph in dot syntax of all objects and rules created
        """
        stmts = []
        objs = set()
        state_color = {WAITING:"gray", READY:"red", STARTED:"blue", FAILED:"green", COMPLETED:"turquoise"}
        for rule in self:
            for input in rule.inputs:
                stmts.append("o{} -> r{}".format(input.id, rule.id))
                objs.add(input)
            for output in rule.outputs:
                stmts.append("r{} -> o{}".format(rule.id, output.id))
                objs.add(output)

            color=state_color[self.get_rule_state(rule.id)]

            stmts.append("r{} [shape=box, label=\"{}\", style=\"filled\" fillcolor=\"{}\"]".format(rule.id, rule.transform.__name__, color))
        for obj in objs:
            stmts.append("o{} [label=\"{}\"]".format(obj.id, obj.get("name")))
        return "digraph { " + (";\n".join(stmts)) + " } "

class Jobs:
    """
        Top level class gluing everything together
    """
    def __init__(self):
        self.rule_set = RuleSet()
        self.rule_templates = []
        self.objects = ObjSet()
        self.object_timestamps = {}

    def to_dot(self):
        return self.rule_set.to_dot()

    def add_template(self, template):
        self.rule_templates.append(template)

    def set_rule_state(self, rule_id, state):
        self.rule_set.set_rule_state(rule_id, state)

    def add_obj(self, obj_props, timestamp):
        """
        Used to record the creation of an object with a given timestamp

        :param obj_props: either a dict or sequence of (key, value) tuples
        :param timestamp:
        """
        obj_id = self.objects.add(obj_props)
        obj = self.objects.get(obj_id)
        self.object_timestamps[obj_id] = timestamp

        new_rules = set()
        for template in self.rule_templates:
            new_rules.update(template(obj, self.objects))

        new_rule_ids = []
        for rule in new_rules:
            new_rule_ids.append(self.rule_set.add_rule(*rule))

        # update those rules where the object is an input.  May transition rules to "READY"
        start_rule_ids = self.rule_set.find_ready_to_start(self.object_timestamps, rules_to_consider=new_rule_ids)
        for rule_id in start_rule_ids:
            self.set_rule_state(rule_id, READY)

        # now find all rules where object is an output.  May transition rules to "COMPLETE"
        for rule_id in self.rule_set.find_finished_rules(obj, self.object_timestamps):
            self.set_rule_state(rule_id, COMPLETED)

    def get_rules_by_state(self, state):
        return self.rule_set.get_rules_by_state(state)


